[{"title":"PHP 判断函数是否存在","url":"/2018/10/06/PHP-判断函数是否存在/","content":"\nPHP 判断函数是否存在有三个函数\n + function_exists 检查给定的函数是否被定义\n + method_exists 检查类的方法是否存在\n + is_callable 检测参数是否为合法的可调用结构\n \n 虽然这三个函数的名字和定义都有差别，但是用起来非常的相似，在部分情况下他们的使用方法完全一致，所以容易混淆。\n \n 下面了解一下每种方法的定义和行为。\n\n## function_exists\n\nfunction_exists 比较简单，只接收一个 string 类型的参数作为要查找的方法名。\n\n它会去系统函数表和用户自定义函数表查找，如果找到相应名字的就会返回 true。**不过这里要注意，PHP 的编译选项可以禁用函数，但是这些函数名是存在于系统函数表的，所以可能会导致 function_exists 会返回 true 但无法调用的情况**。\n\n一定要注意 PHP 的关键字并不是函数，例如 `echo` ，function_exists('echo') 降会返回 bool(false)。\n\n## method_exists\n\nmethod_exists 使用的对象是类，它用来检查类里的方法是否存在。所以它有两个参数 `mixed $object`，`string $method_name`，$object 是所检查的类，$method_name 是检查的方法名。\n\n$object 可以是 object 类型，或者 string 类型，但是要注意，**如果使用了 string 类型参数，并且此类当前无定义，则会触发 PHP 的自动加载机制**。\n\nmethod_exists 并不会在意类中方法的访问修饰符，所以即使在类外部无法调用的 private 方法也会返回 bool(true)。因此 method_exists 也不代表当前可以直接调用此方法。另一个检查类中属性的方法 `property_​exists` 则会检查访问修饰符。\n\nmethod_exists 也不会处理魔术方法 __call()。\n\n## is_callable\n\nis_callable 应该是这三个函数中最复杂的一个。\n\n它有三个参数，`mixed $var`，`bool $syntax_only`，`string &$callable_name`。\n\n第一个参数 $var 是待检查的变量，类型可以是 string 和 array，如果是 array 则代表传入的是类和方法名，分别是数组坐标的0和1，数组里的两个参数和 `method_exists` 方法的两个参数含义一样，**注意这里也可能会触发自动加载**。\n\n第二个参数 $syntax_only 是指的是否只检查是方法或者函数，而不检查是否能调用(这样考虑作用域、访问修饰符等)。默认为 false。\n\n第三个参数 &$callable_name 要注意它是一个引用，is_callable 会给它赋一个这次检查变量的 `callable name`(不知道如何解释)，**注意，即使 is_callable 返回的是 false 这个变量也会被赋值**。它最重要的作用就是给方法定位，返回的值不能直接用来调用，都是静态方法的格式，但是只用来说明归属，如果是函数，则直接是函数名。请看如下代码\n``` PHP\n<?php\nclass B\n{\n    public function bb()\n    {\n        echo 222;\n    }\n}\n\nclass A extends B\n{\n    public function aa() {\n        echo 111;\n    }\n}\n\n$a = new A();\n$b = new B();\n\nvar_dump(is_callable([$a,'bb'], false, $aName));\nvar_dump(is_callable([$b,'bb'], false, $bName));\n\nvar_dump($aname);\nvar_dump($bname);\n\n/* return value\nbool(true)\nbool(true)\nstring(5) \"A::bb\"\nstring(5) \"B::bb\"\n*/\n```\n其中 A 和 B 都是 instanceof B。可以看出差别来。不过此参数一般不使用。\n\nis_callable 与 method_exists 不同，它是会参考类中的魔术方法 __call() 的。\n\n## 使用建议\n\n1. 如果检查是为了接下来正常调用的话，建议只使用 is_callable，函数如其名，它就是用来判断是否可以正常调用。参数使用默认的 $syntax_only = false (这代表检查作用域和访问修饰符等)。第三个参数一般不使用。\n\n2. method_exists 的第一个参数和 is_callable 第一个参数是数组时的第一个变量（也就是要检查的类/对象），都尽量不要使用字符串，应该使用对象，因为类不存在的话会触发自动加载，耗时增加。\n\n3. function_exists 和 method_exists 都会比 is_callable 快，但是缺点很明显，再明确清楚这些缺点不会带来问题的时候再使用这两个方法。\n\n4. is_callable 第二个参数为 true 的时候和 function_exists 和 method_exists 基本一样，只差一个 __call()，但是函数名称的语义就没有用了，一定要确定和你一起开发的人也会这么使用。","tags":["PHP"]},{"title":"PHP Session 的处理","url":"/2018/09/29/PHP-基础-——-Session/","content":"\n## session 启动\nphp 在默认一开始不启动 session，可以在 php.ini 中配置 session.auto_start 打开自动启动 session。\n\n也可以使用 session_start() 函数。session_start()会创建新会话或者重用现有会话。 如果通过 GET 或者 POST 方式，或者使用 cookie 提交了会话 ID， 则会重用现有会话。\n\n不过要注意，如果使用了 cookie 来保持会话，那 session_start() 一定要在内容输出前调用，除非你使用了输出缓存。因为 session_start() 会设置 header，这跟 header() 方法的调用原则一致。会话使用的 cookie 可以通过 session_set_cookie_params() 或者  `session.cookie_lifetime, session.cookie_path, session.cookie_domain, session.cookie_secure, session.cookie_httponly` 这5个PHP 选项来设置。\n\nsession 开始后，PHP 内部会调用会话管理器的 open 和 read 回调函数。 会话管理器可能是 PHP 默认的， 也可能是扩展提供的，也可能是通过 session_set_save_handler 设定的用户自定义会话管理器。\n\n如果启用了 session.use_trans_sid 选项，session_start  函数会注册一个内部输出管理器， 该输出管理器完成 URL 重写的工作。这个选项一般在无法使用 cookie 的场景。\n\nPHP 默认的会话管理器是 files 文件处理器，默认的路径是 `/tmp`，它会在 /tmp 路径下创建一个名为会话id的文件，文件中存储的是 PHP $_SESSION 数组序列化后内容。同样，读取时先反序列化，然后初始化 $_SESSION 超全局变量。\n\nsession_start() 可以接受一个 array $options 的参数，用来设置选项，此时可以不用 `session.` 这个前缀。但是要注意每个配置的的指令作用域，例如 auto_start 就无法在其中设置，当然本身逻辑也说不通。设置的详情请查看 [PHP Session 选项](http://php.net/manual/en/session.configuration.php)。\n\n## session 使用\nPHP 中使用 session 可以直接访问超全局变量 $_SESSION，\n\n$_SESSION 中能放任意类型变量，但是需要 PHP 序列化，或者是用户自定义的会话处理器支持存储读取等，才能正常的使用会话存储这些变量内容。\n\nsession.serialize_handler 的选项可以设置序列化处理器，当前支持 php_serialize，php，php_binary，WDDX\n\n## session 销毁\n\n可以unset($_SESSION['foo']) 来释放某个值。要注意的是，session 启动以后 $_SESSION 变量才会影响会话里记录的值。\nsession_unset() 可以用来释放所有的会话变量。千万不要使用 `unset($_SESSION)` 来释放，虽然 $_SESSION 还可以继续使用，但是已经不再影响会话的记录了。\n\nPHP 中可以关闭或者取消 session 有五个方法，每个方法的作用不同，对比如下\n![session delete](session_delete_function.png)\nsession_unset() 只是清空数据，可以继续使用会话，session_abort() 暂停使用会话，但是数据并不改变，\nsession_destory() 销毁会话，数据不可用，会话也不可用，session_reset() 重置当前的 $_SESSION 为原会话数据，session_write_close()/session_commit() 是把数据写入会话，并关闭当前会话。\n\n## session 状态\nPHP 在处理会话时，使用了三个状态\n\n- PHP_SESSION_DISABLED 会话是被禁用的。\n- PHP_SESSION_NONE 会话是启用的，但不存在当前会话。\n- PHP_SESSION_ACTIVE 会话是启用的，而且存在当前会话。\n\nPHP_SESSION_DISABLED 这个状态比较特殊，一般只有在会话处理器出现了问题才会出现，所以这个状态也代表着当前没有办法打开一个会话。\n\nPHP_SESSION_NONE 代表着会话功能正常，但是并没有启用，所以此时 $_SESSION 变量可有可无，并且不关联会话。\n\nPHP_SESSION_ACTIVE 此时会话正常，在调用 session_start() 后(或者自动启动)进入此状态，$_SESSION 与会话联动，可以保存会话数据。\n\n用状态度大概的表示如下\n![session delete](session_status.png)","tags":["PHP"]},{"title":"Hello World","url":"/2018/09/28/hello-world/","content":"\n折腾好几次个人博客了，都无疾而终。上一次更是悲剧，因为遗忘了它，导致几篇文章丢失了。\n\n我觉得工作和学习中，个人的知识和经验积累非常重要，所以记录是非常的重要。\n\n如果你看到我的博客很久没更新了，请留言督促一下我哈哈。\n\nallen"},{"title":"负载均衡的几种类型","url":"/2016/10/11/负载均衡的几种类型/","content":"> 这篇文章是以前博客的，从转载看到，现在删减后搬运过来。\n\n负载均衡的目的就是让请求到达不同的服务器上。一次请求到服务器之间，有那么多环节，因此可以实现的方法有很多种，实际应用中不外乎以下几种方式。\n\n## HTTP 重定向负载均衡\n\nHTTP 重定向负载均衡有一台重定向服务器，它也是一台普通的服务器，其唯一的功能就是根据用户的 HTTP 请求计算一台应用集群中服务器的地址，并将此地址写入 HTTP 重定向响应中返回给用户。\n\n这种方案实现起来非常简单，但是需要浏览器请求两次服务器才能完成。并且重定向服务器很容易编程瓶颈，因为一次重定向返回的过程，也是一次标准 HTTP 请求，如果集群内有10台机器，那 HTTP 重定向服务器的流量将是应用服务器的10倍，如果有100台估计就要宕机了，所以伸缩性能受到了很大的限制。还有使用302响应码重定向，不利于网站的SEO。\n\n## DNS域名解析负载均衡\n\n这是利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。在 DNS 中配置多个 A 记录，每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回。\n\nDNS 域名解析负载均衡的优点是将负载均衡的工作转交给 DNS，省掉了网站管理维护负载均衡服务器的麻烦，同时还可以使用智能 DNS 可以基于地理位置或者 ISP 来做域名解析，用户将会得到距离最近或者速度最快的一个服务器地址，这样可以加快用户的访问速度，改善性能。\n\n但是这种方法也有很大的缺点，DNS 是多级解析，每一级都会缓存 DNS 记录，如果某个服务器变动了，DNS 记录更新的时间将会很长，这个速度取决于域名服务商。\n\n一般大型网站都会使用 DNS 域名解析，利用域名解析作为一级负载均衡手段。你可以使用 dig <域名> 的方法查看某个域名的A记录，你会发现很多网站会有多条 A 记录。\n\n## 反向代理负载均衡\n\n这种方法就是使用反向代理服务器，它一般在 web 服务器前面，这个位置也正好是负载均衡服务器的位置，所以大多数反向代理服务器同时也提供负载均衡的功能。\n\n由于 web 服务器不直接对外提供访问，因此 web 服务器不需要使用外部 IP，而反向代理服务器则需要配置双网卡和内部外部两套 IP 地址。\n\n反向代理服务器转发请求是在 HTTP 协议层面，因此也叫应用层负载均衡，由于应用层在七层网络模型中的第七层，所以一般也称为七层负载均衡。优点就是和反向代理服务器功能集成在一起，部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。\n\n## 网络层负载均衡\n\n这种方法是在网络层通过修改请求目标地址进行负载均衡，网络层在七层网络层模型的第四层，所以也叫做四层负载均衡，也叫做 IP 层负载均衡。\n\n请求达到负载均衡服务器后，由负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实 web 服务器的地址，然后修改请求的目的地址到这台真实的web服务器地址，等到 web 服务器处理完成后，响应数据包回到负载均衡服务器，再将数据包源地址修改为自身的 IP（负载均衡服务器的 IP）地址发送给用户浏览器。\n\n这里关键在于真实 web 服务器响应数据包如何返回给负载均衡服务器。一种是源地址转换（SNAT），第二种是负载均衡服务器作为网关服务器。\n\n网络层的负载均衡在内核进程完成数据转发，有更好的性能。但是由于响应请求的流量要经过负载均衡服务器，容易成为瓶颈。\n\n## 数据链路层负载均衡\n\n数据链路层主要处理 mac 地址，所以使用修改 mac 地址进行转发请求。\n\n负载均衡数据分发过程中不修改 IP 地址，只修改 mac 地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的。\n\n由于 web 服务器的服务器地址 IP 和数据请求目的 IP 地址一致，不需要通过负载均衡服务器进行地址转换，可将相应数据包直接返回用户。\n\n如果有足够的公有 IP，其实 web 服务器也可以直接使用自己的IP响应请求，不过这样 web 服务器必须绑定负载均衡的虚拟 IP 地址（VIP），才能保证 web 服务器收到来自负载均衡发送的数据包。\n\n这种方式称作三角传输模式，单臂模式，也叫做直接路由方式（DR）。使用 DR 方式的链路层负载均衡是目前大型网站使用最广的一种负载均衡手段。","tags":["网络","基础知识"]}]